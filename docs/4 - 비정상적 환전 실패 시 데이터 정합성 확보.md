# ❓ 문제: 일시적인 네트워크 오류로 인한 데이터 불일치
- 환전 서비스가 계좌 서비스로 입출금을 요청할 때, 여러 가지 문제가 발생할 수 있음

<br>

## 1. 서버 에러(5XX)

- 계좌 서비스 내부 오류로 인해, 5XX 응답을 반환
- 환전 서비스는 계좌 서비스의 트랜잭션 성공/실패 여부를 알 수 없음

<br>

## 2. 타임아웃

- 네트워크 지연 등으로 인해, 계좌 서비스 응답을 수신하기 전에 타임아웃이 발생
- 환전 서비스는 계좌 서비스의 트랜잭션 성공/실패 여부를 알 수 없음

<br>

## 3. 네트워크 단절

- 환전 서비스와 계좌 서비스 간 네트워크 연결이 일시적으로 끊겨, 응답을 받지 못함

- 환전 서비스는 계좌 서비스의 트랜잭션 성공/실패 여부를 알 수 없음

<br>

## 4. 발생 문제

- 'Unknown' 상태의 환전 서비스 내부 상태와 계좌 서비스 실제 상태 간 불일치가 초래됨
- 사용자에게 잘못된 정보를 제공하거나, 금전적 문제가 발생할 수도

<br>

# ❗ 해결: 입출금 재조회 및 상태 보완
- 'Unknown' 상태의 입출금 결과를 파악하기 위해, 계좌 서비스에 결과 조회를 요청
  - 실제 상태를 확인해, 환전 서비스 내부 상태를 보완하는 로직 구현


<br>

## 1. 구현

### 1.1. ExchangeCurrencySagaOrchestratorImpl

- `WithdrawalUnknown` 이벤트 발생 시, 오케스트레이터에서 `checkWithdrawalService.checkWithdrawal()` 호출

  ```java
  @SagaOrchestrator
  @RequiredArgsConstructor
  public class ExchangeCurrencySagaOrchestratorImpl implements ExchangeCurrencySagaOrchestrator {
  
      private final CheckWithdrawalService checkWithdrawalService;
      // ... (생략) ...
      
      // 출금: 결과 알 수 없음
      @Override
      public void handle(WithdrawalUnknown event) {
          // 출금 확인
          checkWithdrawalService.checkWithdrawal(
                  event.requestId(),
                  event.count()
          );
      }
      // ... (생략) ...
  }
  ```

<br>

### 1.2. CheckWithdrawalServiceImpl

- `checkWithdrawal()`: 계좌 서비스에 출금 결과 재조회 요청

  ```java
  @Service
  @RequiredArgsConstructor
  public class CheckWithdrawalServiceImpl implements CheckWithdrawalService {
  
      private final LoadWithdrawalPort loadWithdrawalPort; // 실제 계좌 서비스에 재조회 요청을 보내는 포트
      // ... (생략) ...
  
      @Override
      @Transactional
      public void checkWithdrawal(RequestId requestId, Count count) {
          var exchange = getExchange(requestId);
          Withdrawal withdrawal;
          try {
              // 계좌 서비스에 출금 상태 재조회
              withdrawal = loadWithdrawalPort.loadWithdrawal(exchange);
          } catch (Exception e) {
              // 재조회 실패 시, 재시도 정책에 따라 Unknown 이벤트 다시 발행 또는 경고 메시지 발송
              exchange.handleWithdrawalCheckUnknown(count, retryPolicy);
              publishEventPort.publish(exchange);
              throw e;
          }
          // 재조회 결과에 따라 적절한 이벤트 발행
          publishWithdrawalEvent(withdrawal);
          saveWithdrawal(withdrawal); // 성공 시에만 저장
      }
      // ... (생략) ...
  }
  ```

<br>

## 1. 기술 선택의 이유 및 장점

### 1.1. 데이터 정합성 보장

- 비정상적 상황에서도 최종적인 데이터 일관성을 확보해, 금전 오류를 방지하고 시스템 신뢰도를 향상

<br>

### 1.2. 복원력 향상

- 일시적 네트워크 문제 또는 외부 서비스 장애에 대한 유연한 대응으로, 시스템 복원력을 향상

<br>

### 1.3. 트랜잭션 추적성

- 재조회 요청을 통해 트랜잭션의 최종 상태를 명확히 파악해, 문제 발생 시 원인 분석 및 복구에 용이

<br>

## 2. 단점 및 트레이드오프

### 2.1. 복잡성 증가

- 재조회 로직, 재시도 정책, 이벤트 발행 및 핸들링 로직 구현으로 인한 시스템 복잡성 증가

<br>

### 2.2. 지연 발생

- 'Unknown' 상태에서 최종 상태 확정까지 일정 시간 소요 가능성, 사용자에게 즉각적 피드백 제공 어려움

<br>

# ❓ 문제: 불안정한 외부 서버에 직접 즉각적이고 반복적인 재시도 수행

## 1. 외부 서버 과부하 

- 즉각적이고 반복적인 재시도는 불안정한 계좌 서비스에 추가적인 부하를 유발해, 전체 시스템의 장애 유발 악순환이 반복됨

<br>

## 2. 환전 서비스 리소스 소모

- 재시도 로직을 환전 서비스 내부에 구현하는 경우, 환전 서비스의 리소스(스레드, 메모리 등)를 소모하게 됨
- 그 결과, 환전 서비스 핵심 비즈니스 로직 처리에  영향을 끼쳐 성능이 저하될 수도

<br>

## 3. 책임 분리 원칙 위배

- 재시도 로직은 인프라, 운영 책임이므로, 환전 서비스에서 직접 재시도를 수행하는 경우 책임 분리 원칙을 위배

<br>

# ❗ 해결: Kafka 기반 메시지 스케줄러를 통한 재시도 외부화

- 재시도 로직을 환전 서비스 외부로 분리하고, Kafka, Redis를 사용해 메시지 스케줄러를 구현 

<br>

## 1. 구현

### 1.1. ExchangeCurrencySagaOrchestratorImpl

- `WithdrawalCheckUnknown`, `DepositCheckUnknown` 이벤트 발생 시 즉시 재시도하지 않음
-  `scheduleCheckRequestPort.scheduleCheckRequest()` 를 호출해, 재시도 요청을 스케줄링

```java
@SagaOrchestrator
@RequiredArgsConstructor
public class ExchangeCurrencySagaOrchestratorImpl implements ExchangeCurrencySagaOrchestrator {

    // 조회 요청 지연
    private final ScheduleCheckRequestPort scheduleCheckRequestPort;
	// ... (생략) ...
    
    // 출금 확인: 결과 알 수 없음
    @Override
    public void handle(WithdrawalCheckUnknown event) {
        // 출금 확인 지연
        scheduleCheckRequestPort.scheduleCheckRequest(
                event.exchangeId(),
                event.delay(),
                event.count(),
                event.direction(),
                TransactionType.WITHDRAWAL
        );
    }

    // 입금 확인: 결과 알 수 없음
    @Override
    public void handle(DepositCheckUnknown event) {
        // 입금 확인 지연
        scheduleCheckRequestPort.scheduleCheckRequest(
                event.exchangeId(),
                event.delay(),
                event.count(),
                event.direction(),
                TransactionType.DEPOSIT
        );
    }

}
```

<br>

### 1.2. CheckSchedulingKafkaPublisher

- `CheckSchedulingKafkaPublisher.java`의 위임 핵심 역할 수행

```java
@MessagingAdapter
@RequiredArgsConstructor
public class CheckSchedulingKafkaPublisher implements ScheduleCheckRequestPort {

    private final KafkaSchedulerProperties schedulerProperties;
    private final KafkaTemplate<String, String> kafkaTemplate;
    private final CheckSchedulingTopicMapper checkSchedulingTopicMapper;

    @Override
    public void scheduleCheckRequest(
            ExchangeId exchangeId,
            Duration delay,
            Count count,
            Direction direction,
            TransactionType transactionType
    ) {
        // ... (생략) ...
        var replyTopic  = checkSchedulingTopicMapper.getTopic(transactionType);
        
        var kafkaMessage = MessageBuilder.withPayload(payload)
                .setHeader(KafkaHeaders.TOPIC, schedulerProperties.schedulerTopic())
                .setHeader(KafkaHeaders.REPLY_TOPIC, replyTopic) // 응답 받을 토픽을 헤더에 추가
                .setHeader(schedulerProperties.scheduledTimeMillisHeader(), delay.toMillis()) // 지연 시간을 헤더에 추가
                .build();

        kafkaTemplate.send(kafkaMessage); // Kafka로 메시지 발행
    }
}
```

<br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 외부 시스템 부하 최소화

- 불안정한 외부 시스템에 대한 즉각적이고 반복적인 재시도를 방지해, 부하를 감소시켜 외부 시스템의 회복을 간접적으로 지원

<br>

### 2.2. 환전 서비스 리소스 보호

- 환전 서비스 리소스(스레드, 메모리 등)를 불필요하게 소모하는 것을 방지
- 핵심 비즈니스 로직 처리에 집중

<br>

### 2.3. 책임 분리 및 모듈성 향상

- 비즈니스 로직의 주요 관심사가 아닌 작업을 분리해, 시스템 모듈성 및 유지보수성 향상

<br>

### 2.4. 재사용성

- 메시지 스케줄러는 환전 서비스 외의 다른 도메인 서비스에서도 범용적으로 사용할 수 있음

<br>

### 2.5. 시스템 안정성 향상

- 불안정한 외부 의존성으로부터 핵심 서비스를 보호해, 전체 시스템 안정성을 향상시킴

<br>

## 3. 단점 및 트레이드오프

### 3.1. 아키텍처 복잡성 증가

- 메시지 스케줄러를 별도로 구현해 서비스에 도입하고, Kafka를 사용해 통신하며, 전체 시스템 아키텍처 복잡성이 증가

<br>

### 3.2. 메시지 스케줄러의 가용성

- 메시지 스케줄러 서비스 자체의 고가용성을 확보해야
- 스케줄러 서비스에서 장애가 발생하는 경우, 재시도 로직이 동작하지 않을 수도

<br>

## 4. 다른 기술과의 비교 및 적합성

### 4.1. Spring Retry

- Spring Retry의 `@Retry` 어노테이션을 통한 재시도 로직 구현은 훨씬 간단함
- 하지만 Spring Retry 실행에 환전 서비스 리소스가 소모되고, 환전 서버는 본래 책임('환전')과 분리된 작업을 수행하게 됨