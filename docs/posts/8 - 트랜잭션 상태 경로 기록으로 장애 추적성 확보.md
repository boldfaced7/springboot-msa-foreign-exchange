# ❓ 문제: 분산 트랜잭션의 실패 원인 파악의 어려움

- 분산 환경에서 여러 서비스에 걸쳐 실행되는 환전 프로세스(Saga)가 실패했을 때, **어느 단계에서 어떤 이유로 실패했는지** 정확히 파악하기 어려움
- 각 서비스는 자신만의 로그를 남기지만, 전체 트랜잭션의 흐름을 이해하려면 여러 서비스의 로그를 일일이 수집하고 시간 순서에 따라 재구성해야 하는 번거로움이 있음
- 특히 금전 거래와 직결된 환전 서비스에서 실패 원인을 신속하게 분석하고 복구하지 못하면, 사용자의 신뢰를 잃고 비즈니스에 심각한 영향을 줄 수 있음

<br>

# ❗ 해결: 이벤트 기반 비동기 로깅으로 환전 상태 변경 이력 추적

- FxBank 환전 서비스는 Saga의 각 단계에서 발생하는 **도메인 이벤트를 비동기적으로 처리**하여, 환전 요청의 모든 상태 변경 이력을 데이터베이스에 기록
- 이를 통해 장애 발생 시, 특정 환전 요청이 어떤 단계를 거쳤고 최종적으로 어떤 상태에 머물러 있는지 한눈에 파악 가능
- 이력은 장애 재처리 및 원인 분석의 핵심적인 근거 자료로 활용됨

<br>

## 1. 구현

### 1.1. JpaExchangeStateLog

- 어떤 환전 요청(`requestId`)의 상태(`state`)가 언제(`raisedAt`) 발생했는지 기록하는 `JpaExchangeStateLog` 엔티티를 정의

```java
@Entity
public class JpaExchangeStateLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long logId;
    private Long requestId;

    @Enumerated(EnumType.STRING)
    private Direction direction;

    @Enumerated(EnumType.STRING)
    private ExchangeState state;

    private LocalDateTime raisedAt;
}
```

<br>

### 1.2. LogExchangeStateService

- 각 도메인 이벤트에 해당하는 상태를 `ExchangeState` Enum으로 정의하고, 이를 `JpaExchangeStateLog` 엔티티로 변환하여 저장하는 역할을 수행

```java
@Service
@RequiredArgsConstructor
public class LogExchangeStateService implements LogExchangeStateUseCase {

    private final SaveExchangeStateLogPort saveExchangeStateLogPort;

    @Override
    public void logExchangeCurrencyStarted(LogExchangeStateCommand command) {
        saveLog(command, ExchangeState.EXCHANGE_CURRENCY_STARTED);
    }

    @Override
    public void logWithdrawalSucceeded(LogExchangeStateCommand command) {
        saveLog(command, ExchangeState.WITHDRAWAL_SUCCEEDED);
    }

    // ... (다른 상태 로깅 메소드 생략) ...

    private void saveLog(LogExchangeStateCommand command, ExchangeState exchangeState) {
        ExchangeStateLog exchangeStateLog = toModel(command, exchangeState);
        saveExchangeStateLogPort.save(exchangeStateLog);
    }
    // ...
}
```

<br>

### 1.3. ExchangeStateLogEventHandler

- Saga의 각 단계에서 발행되는 다양한 도메인 이벤트(예: `ExchangeCurrencyStarted`, `WithdrawalSucceeded` 등)를 `@EventListener`로 수신
- `@Async`를 통해 별도의 스레드에서 `LogExchangeStateService`를 호출하여 상태 이력을 비동기적으로 기록
- `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`을 사용하여, 이전 트랜잭션이 성공적으로 커밋된 후에만 이벤트 리스너가 동작하도록 보장

```java
@Component
@RequiredArgsConstructor
public class ExchangeStateLogEventHandler {

    private final LogExchangeStateUseCase logExchangeStateUseCase;

    @Async
    @EventListener
    public void handle(ExchangeCurrencyStarted event) {
        logExchangeStateUseCase.logExchangeCurrencyStarted(toCommand(event));
    }

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handle(WithdrawalSucceeded event) {
        logExchangeStateUseCase.logWithdrawalSucceeded(toCommand(event));
    }

    // ... (다른 이벤트 핸들러 생략) ...
}
```

<br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 명확한 장애 분석 및 추적성 확보

- 특정 환전 ID의 상태 이력만 조회하면, 전체 트랜잭션의 진행 경로와 실패 지점을 정확하고 신속하게 파악 가능

<br>

### 2.2. 비동기 로깅을 통한 성능 영향 최소화

- 상태 기록 로직을 `@Async`를 통해 비동기적으로 처리하므로, 원래의 환전 처리 트랜잭션의 성능에 미치는 영향을 최소화

<br>

### 2.3. 신뢰성 있는 로그 기록

- `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`을 사용하여, 출금과 같은 중요 작업이 실제로 DB에 커밋된 후에만 해당 성공 이벤트를 기록
- 이를 통해 "로그는 남았지만 실제 작업은 롤백되는" 데이터 불일치 상황을 방지

<br>

## 3. 단점 및 트레이드오프

### 3.1. DB 부하 증가

- 모든 트랜잭션의 모든 상태 변경을 기록하므로, 데이터베이스에 쓰기(Write) 작업이 추가적으로 발생
- 트랜잭션 양이 매우 많은 시스템에서는 이로 인한 부하를 고려해야

<br>

### 3.2. 구현 복잡성 증가

- 이벤트 기반 아키텍처는 시스템의 동작을 이해하고 디버깅하는 것을 더 어렵게 만들 수 있음