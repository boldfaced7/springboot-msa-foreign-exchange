# ❓ 문제: 중복 요청으로 인한 금전 오류 위험

- 이벤트 기반 분산 시스템 환경에서는 동일한 요청이 여러 번 처리될 가능성이 존재
- 특히 금융 거래와 같이 민감한 시스템에서는 이러한 중복 처리로 인해 심각한 금전적 오류가 발생할 수도

<br>

## 1. 중복 요청 원인

### 1.1 사용자 재시도

- 사용자 환전 요청 후 네트워크 문제로 응답을 받지 못했을 때, 사용자가 동일한 요청을 재전송

<br>

### 1.2. 메시지 큐 중복 전달

- 환전 서비스 내부의 메시지 큐(예: Kafka)를 통한 이벤트 처리 과정에서 메시지가 중복으로 전달됨

<br>

### 1.3. 어플리케이션 이벤트 중복 발행

- 구현 상의 문제로 이벤트가 중복 발행되어, 동일한 요청이 중복되어 전송됨

<br>

## 2. 시스템의 중복 요청 미처리 시 발생 가능한 문제

### 2.1. 중복 입출금

- 동일한 환전 요청에 대해 사용자 계좌에서 금액이 이중으로 입/출금되어, 금전 오류 발생

<br>

### 2.2. 데이터 불일치

- 시스템 전체 데이터의 정합성이 훼손되어 신뢰할 수 없는 상태가 됨

<br>

# ❗ 해결: Idempotency Key를 Redis에 캐싱하여 중복 처리 방지

- FxBank 환전 서비스는 모든 환전 요청에 대해 고유한 `Idempotency Key`(`ExchangeId`)를 부여하고, 이 키를 Redis에 저장하여 중복 요청을 선제적으로 차단

<br>

## 1. 구현 상세

### 1.1. @Idempotent

- 멱등성 처리가 필요한 비즈니스 로직 메서드에 적용하는 커스텀 어노테이션

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {

    String key();
    String prefix();
    long expiration() default 5L;
    TimeUnit timeUnit() default TimeUnit.MINUTES;
    Class<? extends RuntimeException> exceptionOnDuplicate() default DuplicateRequestException.class;
}
```

<br>

### 1.2. IdempotentAspect

- `@Idempotent`가 적용된 메서드 호출을 가로채, 멱등성 로직을 수행
- Spring AOP로 비즈니스 로직과 멱등성 로직을 분리하여, 코드의 응집도를 높임



- `checkAndSet()`: Redis의 `setIfAbsent()`을 이용하여 키 조회 및 저장을 원자적으로 수행한 후 대상 메서드 실행

```java
@Aspect
@Component
@RequiredArgsConstructor
@Order(Ordered.HIGHEST_PRECEDENCE)
public class IdempotentAspect {

    private final StringRedisTemplate redisTemplate;

    @Around("@annotation(com.boldfaced7.fxexchange.exchange.application.port.aop.Idempotent)")
    public Object checkIdempotency(ProceedingJoinPoint joinPoint) throws Throwable {...}

    private Object checkAndSet(ProceedingJoinPoint joinPoint, Idempotent annotation, String key) throws Throwable {
        try {
            Boolean isSet = redisTemplate.opsForValue()
                	.setIfAbsent(key, "1", annotation.expiration(), annotation.timeUnit());

            if (Boolean.FALSE.equals(isSet)) {
                throw annotation.exceptionOnDuplicate().getConstructor().newInstance();
            }
            return joinPoint.proceed();
            
        } catch (Exception e) {...}
    }
}
```

<br>

### 1.3. CreateExchangeRequestServiceImpl: 중복 요청 대응

- 환전 요청 생성 및 영속화 이전에 멱등성 키를 검사해, 중복 요청을 선제적으로 차단

```java
@Service
@RequiredArgsConstructor
public class CreateExchangeRequestServiceImpl implements CreateExchangeRequestService {

    private final SaveExchangeRequestPort saveExchangeRequestPort;
    private final PublishEventPort publishEventPort;

    @Override
    @Transactional
    @Idempotent(
            prefix = "exchange:request:",
            key = "#toBeSaved.exchangeId",
            exceptionOnDuplicate = ExchangeAlreadyRequestedException.class
    )
    public ExchangeRequest createExchangeRequest(ExchangeRequest toBeSaved) {
        var saved = saveExchangeRequestPort.save(toBeSaved);
        saved.markExchangeCurrencyStarted();
        publishEventPort.publish(saved);
        return saved;
    }
}
```

<br>

### 1.4. CompleteWithdrawalCancelService: 메시지 큐 중복 전달 대응

- 카프카에서 메시지를 중복하여 전송할 수 있으므로, 영속화 이전에 멱등성 키를 검사해, 중복 요청을 선제적으로 차단

```java
@UseCase
@RequiredArgsConstructor
public class CompleteWithdrawalCancelService implements CompleteWithdrawalCancelUseCase {

    private final LoadExchangeRequestCachePort loadExchangeRequestCachePort;
    private final SaveWithdrawalCancelPort saveWithdrawalCancelPort;
    private final PublishEventPort publishEventPort;

    @Override
    @Transactional
    @Idempotent(prefix = "cancel-withdrawal:response:", key = "#command.exchangeId")
    public void completeWithdrawalCancel(CompleteWithdrawalCancelCommand command) {
        var exchange = getExchange(command.exchangeId());
        var withdrawalCancel = toDomain(exchange, command);

        publishEventPort.publish(withdrawalCancel);
        saveWithdrawalCancelPort.saveWithdrawalCancel(withdrawalCancel);
    }
    // ... (생략) ...
}
```

<br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 선제적 중복 처리 방지

- 요청 처리의 가장 초기 단계(AOP 인터셉트)에서 중복 요청을 필터링
- 불필요한 리소스 낭비(DB 접근, 다른 서비스 호출 등)를 방지하고 핵심 비즈니스 로직의 중복 실행을 원천적으로 차단

<br>

### 2.2. 시스템 부하 감소

- 중복 요청이 핵심 비즈니스 로직에 도달하기 전에 차단되므로, DB 및 다른 마이크로서비스에 가해지는 불필요한 부하를 줄여 시스템의 안정성과 확장성에 기여

<br>

## 3. 단점 및 트레이드오프

### 3.1. Redis 의존성

- 멱등성 보장 메커니즘이 Redis에 일부 의존하므로, Redis 서버의 가용성 및 성능이 전체 시스템의 안정성에 영향을 끼침
- Redis 장애에 대응하기 위해 Redis 클러스터링, Sentinel 등을 통한 고가용성 구성이 필요

<br>

### 3.2. 메모리 사용량

- 모든 Idempotency Key를 Redis에 저장하므로, 요청 수가 증가하면 Redis의 메모리 사용량도 증가할 수도
- 적절한 만료 시간 설정과 주기적인 삭제 전략을 통해 메모리 사용량을 관리해야

<br>

## 4. 다른 기술과의 비교 및 적합성

### 4.1. DB 제약 조건

- 데이터베이스의 제약 조건(`UNIQUE KEY`, `PRIMARY KEY`)을 활용하여 DB 레벨에서 멱등성 보장도 가능
- Redis 캐싱 방식으로 선제적으로 중복 요청을 차단하여 DB 부하를 줄이고, 응답 속도를 향상시킴
- DB `UNIQUE KEY`는 최종 방어선 역할을 수행하도록 구현

<br>

### 4.2. 분산 락(Distributed Lock)

- Redis 분산 락은 멀티 인스턴스 환경에서 특정 코드 블록의 동시 실행을 통제할 때 유용
- 하지만 FxBank 환전 서비스는 환전 요청을 여러 인스턴스에서 동시에 상태를 변경하는 경우가 없어, 분산 락을 사용할 필요는 없음

<br>

# ❓ 문제: Redis 캐싱만으로는 부족한 최종적인 멱등성 보장

- Redis 캐싱을 통해 Idempotency Key를 관리하는 경우, 대부분의 중복 요청을 효과적으로 차단
- 하지만 극단적 상황에서는 Redis 캐싱만으로 완벽한 멱등성을 보장하기 어려움
  - 발생 빈도는 낮지만 금융 거래에서의 단 한 번의 중복 처리도 치명적 금전 오류로 이어질 수 있음

<br>

## 1. Redis 장애

- Redis 서버 장애 발생 시 Idempotency Key 조회/저장 불가

<br>

## 2. Redis 데이터 유실

- Redis 데이터 유실 시 이미 처리된 요청이 중복 처리됨

<br>

# ❗ 해결: `UNIQUE KEY` 제약 조건을 통한 최종적인 멱등성 보장

## 1. 구현 상세

### 1.1. JpaExchangeRequest

- JPA `@Table`, `@UniqueConstraint`로 UNIQUE KEY 제약 조건 설정

```java
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Table(uniqueConstraints = {
        @UniqueConstraint(name = "uk_exchange_id", columnNames = {"exchange_id"})
})
public class JpaExchangeRequest {...}
```

<br>

### 1.2. ExchangeRequestPersistenceAdapter

- 어댑터 클래스에서 `DataIntegrityViolationException`를 어플리케이션 예외로 변환

```java
@PersistenceAdapter
@RequiredArgsConstructor
public class ExchangeRequestPersistenceAdapter implements
        LoadExchangeRequestPort,
        SaveExchangeRequestPort,
        UpdateExchangeRequestPort
{
    private final JpaExchangeRequestRepository jpaExchangeRequestRepository;

    @Override
    public ExchangeRequest save(ExchangeRequest exchange) {
        try {
            return persist(exchange);
        } catch (DataIntegrityViolationException e) {
            throw new ExchangeAlreadyRequestedException();
        }
    }

    private ExchangeRequest persist(ExchangeRequest exchange) {
        var toBePersisted = ExchangeRequestMapper.toJpa(exchange);
        var persisted = jpaExchangeRequestRepository.save(toBePersisted);
        return ExchangeRequestMapper.toDomain(persisted);
    }
    // ... (생략) ... 
}
```

<br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 최종적인 멱등성 보장

- Redis 캐싱이 실패하거나, Redis 캐싱을 우회하는 극단적 상황에서도 DB 수준에서 중복 삽입을 원천적으로 차단해, 강력한 멱등성 보장

<br>

### 2.2. 데이터 무결성 확보

- DB 제약 조건 활용을 통해 데이터 무결성을 강력하게 유지

<br>

### 2.3. 이중 방어 체계

- 애플리케이션 레벨(Redis 캐싱)과 DB 레벨(UNIQUE KEY)에서 이중으로 멱등성을 보장해, 시스템 신뢰도 극대화

<br>

### 2.4. 간단한 구현

- JPA `@UniqueConstraint`을 통해 선언적으로 `UNIQUE KEY` 제약 조건을 적할 수 있어, 구현이 간편

<br>

## 3. 단점 및 트레이드오프

### 3.1. 성능 오버헤드

- DB `UNIQUE KEY` 제약 조건 컬럼 데이터 삽입 시, DB의 키 유일성 검사로 인해 약간의 성능 오버헤드 발생

<br>

### 3.2. 예외 처리

- 중복 삽입으로 DB 예외가 발생하는 경우, 애플리케이션 레벨에서 적절하게 예외 처리를 수행하고, 사용자 친화 메시지를 제공하거나 재시도 로직 구현해야

<br>

## 4. 다른 기술과의 비교 및 적합성

### 4.1. Redis 캐싱과 UNIQUE KEY 제약 조건

- Redis 캐싱의 빠른 응답 속도를 사용해, 대부분의 중복 요청을 선제적으로 차단하며 시스템 부하를 감소시킬 수 있음
- DB `UNIQUE KEY`는 최종적 데이터 무결성을 보장
- 두 방식의 상호 보완을 통해, 강력한 멱등성 보장 체계 구축이 가능
