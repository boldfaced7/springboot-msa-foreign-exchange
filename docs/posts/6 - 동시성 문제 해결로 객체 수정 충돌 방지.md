# ❓ 문제: 분산 환경에서 데이터베이스 레벨의 동시성 충돌

## 1. 비동기 다단계 작업 중 동시성 충돌

- 환전 서비스는 Saga 패턴을 활용하여 비동기적으로 여러 단계를 거쳐 작업을 완료
- 이 정에서 여러 이벤트 핸들러가 동시에 동일한 `ExchangeRequest` 객체의 상태를 업데이트하려고 시도할 수도

<br>

## 2. 금전 오류 발생

- 환전 요청 처리의 동시성이 보장되지 않으면, 중복 출금이나 중복 입금과 같은 심각한 금전 오류로 이어질 수도

<br>

# ❗ 해결: JPA `@Lock`과 `@QueryHint`를 활용한 DB 비관적 락

## 1. 구현 상세

### 1.1. JpaExchangeRequestRepository

- FxBank 환전 서비스의 JPA `@Lock` 로 DB 레벨 비관적 락 적용
- `@QueryHint`로 락 획득을 위한 최대 대기 시간을 지정하여, 시간 내에 락을 획득하지 못하는 경우 예외 발생시켜 무한 대기를 방지

```java
public interface JpaExchangeRequestRepository extends JpaRepository<JpaExchangeRequest, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE) // 비관적 쓰기 락 적용
    @Query("SELECT e FROM JpaExchangeRequest e WHERE e.requestId = :requestId")
    @QueryHints( // 락 타임아웃 힌트
            @QueryHint(name = "jakarta.persistence.lock.timeout", value = "1000")
    )
    Optional<JpaExchangeRequest> findByRequestIdForUpdate(Long requestId);
    
    
    // ... (생략) ...
}
```

<br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 강력한 데이터 일관성 보장

- DB 레벨에서 동시 업데이트 충돌을 차단하여, 데이터 수정 충돌 문제를 방지하고, 데이터 일관성을 강력하게 보장

<br>

### 2.2. 비즈니스 로직의 단순화

- 어플리케이션 레이어에 동시성 제어 로직 구현할 필요가 없음
  - JPA 어노테이션을 통한 선언적 락 적용으로 비즈니스 로직 복잡성 감소


<br>

## 3. 단점 및 트레이드오프

### 3.1. 성능 저하

- 락을 획득 동안 다른 트랜잭션이 대기하는 경우, 동시성 높은 환경에서 성능 병목 현상이 발생할 수도
  - 락 장기 유지 또는 여러 트랜잭션의 동일 리소스 접근 시 성능 저하가 두드러짐

<br>

### 3.2. 데드락 위험

- 여러 트랜잭션이 서로 다른 순서로 락 획득을 시도 시, 데드락이 발생할 수도
  - 락 획득 순서의 일관성을 유지하고, 락 타임아웃을 적절하게 설정하는 것이 중요

<br>

### 3.3. 데이터베이스 의존성

- 특정 DB 락 메커니즘에 의존할 수 있고, DB 종류에 따른 락 동작 방식/성능 특성이 상이할 수도

<br>

## 4. 다른 기술과의 비교 및 적합성

### 4.1. 낙관적 락

#### 4.1.1. 작동 방식

- 별도의 락 없이 트랜잭션을 진행하고, 커밋 시점에 데이터 변경 여부를 확인
- 일반적으로 버전 필드를 사용하여 충돌을 감지하며, 충돌 발생 시 `OptimisticLockException`을 발생시켜 애플리케이션 레벨에서 재시도 또는 실패 처리가 필요

<br>

#### 4.1.2. 장점

-   **성능 이점:** 충돌이 적을 것으로 예상되는 환경에서 락 대기 없이 트랜잭션을 처리하므로, 성능상 이점이 존재

<br>

#### 4.1.3. 단점 및 적합성

-   **금융 시스템에 부적합:** 금융 시스템과 같이 데이터 정합성이 중요하고, 재시도 자체가 이중 송금/이벤트와 같은 심각한 부작용을 초래할 수 있는 도메인에 적합하지 않음
-   **외부 시스템 연동 및 긴 트랜잭션에 부적합:** 외부 시스템 연동과 같은 부작용이 있는 트랜잭션이나 트랜잭션 길이가 길어 충돌 확률이 높은 경우에 적합하지 않음

</br>

-   FxBank 환전 서비스와 같이 실패를 허용할 수 없는 금융 거래에서는 처음부터 동시성 자체를 막는 비관적 락이 더 신뢰성 있고 보수적인 접근 방식

<br>

### 4.2. Redis 분산 락(Redisson)

#### 4.2.1. 작동 방식

-   Redisson은 Redis를 기반으로 하는 분산 락 구현체로, 분산 환경에서 여러 애플리케이션 인스턴스나 스레드가 공유 리소스에 동시에 접근하는 것을 제어하기 위해 사용
-   Redisson은 락의 재진입(reentrancy), 락 획득 시도 시 대기(blocking), 락 만료 시간 자동 연장(watchdog), 락 해제 시 신호(signal) 등 분산 락에 필요한 복잡한 로직을 추상화하여 제공
-   클라이언트가 락을 획득하면 Redis에 특정 키를 설정하고, 락을 해제하면 해당 키를 삭제하는 방식으로 동작하며, 락 획득 시 만료 시간을 설정하여 데드락 방지

<br>

#### 4.2.2. 장점

-   **분산 환경 동시성 제어:** 여러 서버에 분산된 애플리케이션 인스턴스 간의 공유 리소스 접근을 효과적으로 제어
-   **높은 가용성 및 성능:** Redis는 인메모리 데이터 저장소로 빠른 처리 속도를 제공하며, 클러스터 구성 시 높은 가용성 보장
-   **유연성:** 다양한 락 구현 전략(예: Redlock 알고리즘)을 적용하여 복잡한 분산 락 시나리오에 대응 가능

<br>

#### 4.2.3. 단점 및 적합성

-   **성능 오버헤드:** 락 획득 및 해제 과정에서 네트워크 통신이 발생하여 성능 저하를 유발할 수 있음
-   **구현 복잡성:** 락의 획득, 해제, 만료 시간 관리, 데드락 방지 등 견고한 분산 락을 구현하기 위한 로직이 복잡
-   **멱등성 검사와의 중복:** FxBank 환전 서비스의 경우, 이미 Redis `SETNX`를 활용한 멱등성 검사를 통해 중복 요청 및 동시성 문제를 상당 부분 해결하고 있음

</br>

-   `SETNX` 기반 멱등성 검사가 기본적인 락의 역할도 수행하므로, 추가적인 Redis 분산 락 도입은 불필요한 복잡성과 처리 시간 증가를 야기할 수 있음
-   따라서 FxBank 환전 서비스와 같이 단일 리소스에 대한 갱신이 단 한 번 발생하고 멱등성 검사로 충분히 동시성 제어가 가능한 경우, 별도의 Redis 분산 락보다는 기존 멱등성 검사 방식이 더 경량화되고 효율적