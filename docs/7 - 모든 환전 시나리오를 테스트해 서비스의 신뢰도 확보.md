# ❓ 문제: 비동기 이벤트 기반 Saga 오케스트레이터 테스트의 어려움

## 1. 외부 의존성

- Saga 오케스트레이터는 데이터베이스(DB), 메시지 큐(Kafka), 외부 계좌 서비스 등 다양한 외부 시스템에 의존
- 실제 의존성을 연결하여 테스트할 경우, 긴 실행 시간, 복잡한 환경 구축, 그리고 외부 시스템의 불안정성으로 인해 테스트 결과에 영향을 받을 수도

</br></br>

## 2. 비동기성

- 비동기적인 이벤트 및 로직 흐름을 테스트하기 어려움
- 이벤트 발생 순서나 처리 시점에 따라 결과가 달라질 수 있어, 테스트의 재현성(Reproducibility)이 저하됨

</br></br>

## 3. 복잡한 시나리오

- 성공 케이스 외에도 출금/입금 실패, 재조회 실패, 보상 트랜잭션 실패 등 다양한 실패 케이스를 검증해야 하므로 테스트 케이스의 수가 증가하고 복잡성이 증대됨

</br></br>

# ❗ 해결: 이벤트 발행기를 제외한 모든 Port를 모킹하여 Application Layer 단위 테스트 수행

## 1. 구현 상세

### 1.1. ExchangeCurrencyServiceApplicationTest

- 각 시나리오에 필요한 포트를 모킹해, 모든 시나리오를 검증

```java
@Slf4j
@SpringBootTest
@ActiveProfiles("application-test")
class ExchangeCurrencyServiceApplicationTest extends ApplicationTestSupport {

    @Autowired ExchangeCurrencyUseCase exchangeCurrencyService;
    @MockitoBean RequestDepositPort requestDepositPort;
    @MockitoBean RequestWithdrawalPort requestWithdrawalPort;

    // ... (생략) ...

    @Test
    @DisplayName("출금 성공 → 입금 성공 → 환전 성공")
    void 출금_성공_입금_성공_환전_성공() {
        // Given
        stubWithdrawalRequest(Result.SUCCESS);                   // 1. 출금 성공 stubbing
        stubDepositRequest(Result.SUCCESS);                      // 2. 입금 성공 stubbing

        // When
        var result = exchangeCurrencyService.exchangeCurrency(EXCHANGE_CURRENCY_COMMAND);

        // Then
        assertThat(result).isNotNull();

        verifySaga(() -> {
            verifyWithdrawalRequest(Result.SUCCESS);              // 1. 출금 성공 검증
            verifyDepositRequest(Result.SUCCESS);                 // 2. 입금 성공 검증
        });
    }
    
    void stubWithdrawalRequest(Result result) {
        OngoingStubbing<Withdrawal> when = when(requestWithdrawalPort.withdraw(any()));

        switch (result) {
            case SUCCESS -> when.thenReturn(withdrawal(true, true));
            case FAILURE -> when.thenReturn(withdrawal(true, false));
            case UNKNOWN -> when.thenThrow(new RuntimeException("Unknown withdrawal result"));
        }
    }
    
    void stubDepositRequest(Result result) {
        OngoingStubbing<Deposit> when = when(requestDepositPort.deposit(any()));

        switch (result) {
            case SUCCESS -> when.thenReturn(deposit(true, true));
            case FAILURE -> when.thenReturn(deposit(true, false));
            case UNKNOWN -> when.thenThrow(new RuntimeException("Unknown deposit result"));
        }
    }
    
    void verifyWithdrawalRequest(Result result) {
        verify(requestWithdrawalPort).withdraw(any());

        if (result.equals(Result.UNKNOWN)) {
            verify(saveExchangeRequestCachePort).save(any());
        } else if (result.equals(Result.SUCCESS)) {
            verify(saveWithdrawalPort).saveWithdrawal(any());
        }
    }
    
    void verifyDepositRequest(Result result) {
        verify(requestDepositPort).deposit(any());

        if (result.equals(Result.UNKNOWN)) {
            verify(saveExchangeRequestCachePort).save(any());
        } else if (result.equals(Result.SUCCESS)) {
            verify(saveDepositPort).saveDeposit(any());
        }
    }
    // ... (생략)...
}

```

</br></br>

## 2. 기술 선택의 이유 및 장점

## 2.1. 테스트 속도 향상

- 실제 DB, 메시지 큐, 외부 서비스 통신 없이 메모리 상에서 테스트가 실행되므로 빠른 테스트 실행 시간을 보장
  - 이는 개발 주기를 단축하고 빠른 피드백을 가능하게 함


</br></br>

## 2.2. 테스트의 독립성 및 재현성

- 외부 의존성으로부터 독립적으로 테스트를 수행하므로, 외부 시스템 상태나 네트워크 환경의 영향 없이 항상 동일한 결과를 보장

</br></br>

### 2.3. 결함 격리

- 특정 계층(Application Layer)의 로직에 집중하여 테스트함으로써 문제 발생 시 해당 계층을 파악하고 결함을 격리하기 용이

</br></br>

### 2.4. 비즈니스 로직 검증

- Saga 오케스트레이터의 복잡한 비즈니스 로직(Saga 시작, 이벤트 핸들링, 상태 전이 등)을 다양한 시나리오에 따라 정확하게 검증 가능

</br></br>

### 2.5. 개발 생산성 향상

- Mockito와 같은 모킹 프레임워크를 활용하여 외부 의존성을 쉽게 모의할 수 있어 테스트 코드 작성의 편의성을 높이고 개발 생산성을 향상시킴

</br></br>

## 3. 단점 및 트레이드오프

### 3.1. 통합 문제 간과 가능성

- Application Layer 단위 테스트만으로는 실제 시스템 통합 시 발생할 수 있는 문제(외부 서비스 연동 오류, 메시지 포맷 불일치, 네트워크 설정 오류 등)를 발견하기 어려움

</br></br>

### 3.2. 모킹의 오용

- 과도한 모킹은 실제 구현과의 괴리를 발생시키거나, 테스트가 세부 구현에 종속되어 리팩토링 시 테스트 코드를 자주 수정해야 할 필요성을 야기할 수도

</br></br>

### 3.3. 실제 환경과의 차이

- 모의 객체 사용으로 인해 실제 운영 환경과의 차이가 존재할 수도

</br></br>

# ❓ 문제: 단위 테스트만으로는 부족한 분산 시스템의 신뢰성 검증

단위 테스트는 특정 컴포넌트의 로직을 빠르게 검증하는 데 효과적이지만, 분산 시스템의 복잡한 통합 시나리오에서는 다음과 같은 문제들을 발견하기 어렵습니다.

## 1. 서비스 간 통신 오류

- HTTP 호출, 메시지 큐 통신 등 실제 네트워크 통신에서 발생할 수 있는 연결 오류, 타임아웃, 메시지 포맷 불일치와 같은 문제들은 단위 테스트만으로는 검증하기 어려움

</br></br>

## 2. 외부 시스템 연동 문제

- 데이터베이스(DB), Redis, Kafka, 외부 계좌 서비스 등 실제 외부 시스템과의 연동에서 발생할 수 있는 설정 오류, 드라이버 문제, 버전 불일치 등은 단위 테스트로 파악하기 어려움

</br></br>

## 3. 분산 트랜잭션의 복잡성

- Saga 패턴과 같이 비동기적으로 진행되는 분산 트랜잭션의 전체 흐름과 데이터 정합성을 단위 테스트만으로 완벽하게 검증하는 데는 한계가 존재

</br></br>

## 4. 환경 의존성

- 개발, 테스트, 운영 환경 간의 미묘한 차이로 인해 발생하는 문제들은 단위 테스트만으로는 포착하기 어려움

</br></br>

# ❗ 해결: Testcontainers, MockWebServer, Kafka 기반 통합 테스트 구성

- FxBank 환전 서비스는 `ExchangeCurrencyServiceIntegrationTest`와 같은 통합 테스트 클래스를 활용하여 실제 운영 환경과 유사한 테스트 환경을 동적으로 구축하고 다양한 환전 시나리오를 검증

</br></br>

## 1. 구현 상세

### 1.1. Testcontainers를 통한 실제 의존성 관리

- `TestContainerSupport` 클래스 상속을 통해 MySQL, Kafka, Redis 등 핵심 인프라를 Docker 컨테이너로 동적 실행
- 각 테스트 실행 시 깨끗한 DB 및 메시지 큐를 제공하여 테스트의 독립성과 재현성을 향상
- `@DynamicPropertySource`를 사용하여 Spring Boot 애플리케이션이 동적으로 생성된 컨테이너의 포트에 연결되도록 설정

</br></br>

### 1.2. MockWebServer를 통한 외부 HTTP 서비스 모의

- `MockWebServer`를 사용하여 `fx-account-service`, `krw-account-service` 등 외부 계좌 서비스의 HTTP 응답을 모의
- `enqueueResponse` 및 `enqueueErrorResponse` 메서드를 통해 성공, 실패, 지연 등 다양한 응답 시나리오를 설정 가능
- 이를 통해 실제 외부 서비스의 가용성에 대한 의존성을 제거하고, 테스트 속도를 유지하며, 외부 서비스의 특정 응답에 대한 환전 서비스의 동작을 정확하게 검증

</br></br>

### 1.3. Kafka Listener를 통한 비동기 메시지 흐름 검증

- 테스트 클래스 내부에 `@KafkaListener`를 사용하여 메시지 스케줄러(`mockScheduler`) 및 계좌 서비스 출금 취소(`mockAccountWithdrawalCancel`)와 관련된 Kafka 메시지를 수신하고 처리하는 모의 컨슈머를 구현
- 이를 통해 환전 서비스가 발행하는 Kafka 메시지가 올바른 토픽으로 전송되는지, 메시지 스케줄러/계좌 서비스가 메시지를 제대로 처리하는지, 그리고 응답 메시지가 환전 서비스로 회귀하는지 등 전체 비동기 흐름을 검증

</br></br>

```java
@ActiveProfiles("integration-test")
@SpringBootTest
class ExchangeCurrencyServiceIntegrationTest extends TestContainerSupport {

    static MockWebServer mockWebServer; // 외부 HTTP 서비스 모의

    @DynamicPropertySource // MockWebServer URL 동적 설정
    static void configureProperties(DynamicPropertyRegistry registry) throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();
        String baseUrl = mockWebServer.url("/").toString();
        registry.add("web-client.fx-account-base-url", () -> baseUrl);
        registry.add("web-client.krw-account-base-url", () -> baseUrl);
    }

    // ... (생략) ...

    @Test
    @DisplayName("출금 성공 → 입금 성공 → 환전 성공")
    void 출금_성공_입금_성공_환전_성공() {
        // Given: MockWebServer에 성공 응답 대기열 추가
        enqueueResponse(WITHDRAWAL_SUCCESS);
        enqueueResponse(DEPOSIT_SUCCESS);

        // When: 환전 서비스 실행
        exchangeCurrencyService.exchangeCurrency(EXCHANGE_CURRENCY_COMMAND);

        // Then: 모델 상태 및 로그 검증 (Awaitility를 사용하여 비동기 처리 완료 대기)
        assertModelsAndStates(
                Exchanged.FINISHED, 
                Withdrawn.WITHDRAWN, 
                Deposited.DEPOSITED, 
                WithdrawalCancelled.NOT_CANCELLED,
            
                ExchangeState.EXCHANGE_CURRENCY_STARTED, 
                ExchangeState.WITHDRAWAL_SUCCEEDED, 
                ExchangeState.EXCHANGE_CURRENCY_SUCCEEDED
        );
    }

    // ... (다양한 실패 시나리오 테스트 케이스) ...

    @KafkaListener( // Kafka 메시지 스케줄러 모의
            topics = "${kafka.scheduler.scheduler-topic}",
            groupId = "${spring.kafka.consumer.group-id}"
    )
    void mockScheduler(
        	@Header(KafkaHeaders.REPLY_TOPIC) String replyTopic, 
        	@Payload String payload, 
        	Acknowledgment ack
    ) {
        kafkaTemplate.send(replyTopic, payload); // 수신한 메시지를 즉시 REPLY_TOPIC으로 다시 전송
        ack.acknowledge();
    }
    // ... (다른 Kafka Listener 모의) ...
}
```

</br></br>

## 2. 기술 선택의 이유 및 장점

### 2.1. 실제 환경에 가까운 테스트

- 실제 DB, 메시지 큐, 외부 서비스와의 상호작용을 검증하여 운영 환경에서 발생할 수 있는 문제들을 조기에 발견 가능

</br></br>

### 2.2. 높은 신뢰도

- 복잡한 분산 트랜잭션의 모든 성공 및 실패 시나리오를 포괄적으로 테스트하여 시스템 전반의 신뢰도 향상

</br></br>

### 2.3. 결함 조기 발견

- 통합 단계에서 문제를 개발 단계에서 발견함으로써 배포 후 심각한 장애를 예방하고 수정 비용을 절감 가능

</br></br>

### 2.4. 테스트 독립성 및 재현성

- Testcontainers를 통해 각 테스트가 독립적인 환경에서 실행되므로 테스트 간 간섭을 방지하고 동일한 결과 보장

</br></br>

## 3. 단점 및 트레이드오프

### 3.1. 테스트 실행 시간

- 단위 테스트에 비해 실제 인프라 구동 및 상호작용 시간이 소요되므로 테스트 실행 시간이 길어짐

</br></br>

### 3.2. 환경 구축 복잡성

- Testcontainers, MockWebServer, Kafka 등 여러 도구를 사용해야 하므로 초기 환경 구축 및 설정이 복잡할 수도

</br></br>

### 3.3. 리소스 소모

- Docker 컨테이너 실행으로 인해 시스템 리소스(CPU, 메모리) 소모가 증가

</br></br>

## 4. 다른 기술과의 비교 및 적합성

### 4.1. 단위 테스트와의 상호 보완

- 통합 테스트는 단위 테스트의 단점을 보완하며, 두 유형의 테스트를 병용하는 것이 효과적인 테스트 전략
- 단위 테스트는 개별 로직의 정확성을 빠르게 검증하는 반면, 통합 테스트는 구성 요소 간의 상호작용 및 전체 흐름의 신뢰성을 확보